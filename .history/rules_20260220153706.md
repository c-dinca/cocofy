# Cocofy – Cursor AI Development Prompt

## Project Overview

Cocofy is a self-hosted music streaming app (like a personal Spotify) built with:

- **Backend:** Python FastAPI (`app.py`)
- **Frontend:** Single-file HTML/CSS/JS (`templates/index.html`)
- **Music source:** YouTube via yt-dlp
- **Deployment:** Docker container on a home server (Ubuntu), auto-deployed via GitHub Actions + Watchtower

The app runs on a home server accessible via Tailscale VPN from MacBook and iPhone.

## Architecture

```txt
cocofy/
├── app.py                 # FastAPI backend
├── templates/
│   └── index.html         # Full frontend (HTML + CSS + JS in one file)
├── Dockerfile             # Docker build
├── docker-compose.yml     # Production deployment
├── requirements.txt       # Python dependencies
├── start.sh               # Local dev start script
└── .github/workflows/
    └── build.yml           # CI/CD pipeline
```

## Current API Endpoints

- `GET /` – Serves the frontend
- `GET /api/search?q=` – Searches YouTube via yt-dlp
- `POST /api/download?url=&title=&artist=` – Downloads song to server
- `GET /api/stream/{video_id}` – Streams audio file
- `GET /api/cover/{video_id}` – Returns embedded cover art
- `GET /api/library` – Lists all downloaded songs
- `DELETE /api/library/{video_id}` – Deletes a song

## Current Features

- YouTube search with auto-complete delay
- Click to download + auto-play
- Persistent library in sidebar
- Cover art extraction from MP3 metadata
- Basic audio player with progress bar, volume, prev/next
- Mobile responsive layout
- Toast notifications
- Keyboard shortcut (Space = play/pause)

## Tech Stack & Constraints

- Backend must stay FastAPI + Python
- Frontend is a single HTML file (no build step, no React, no npm)
- Music downloads via yt-dlp (installed in Docker container)
- Audio format: MP3 (best quality)
- Must work on Safari (MacBook) and Safari/Chrome (iPhone via Tailscale)
- Docker container deployed on low-end hardware (i5-4210U, 8GB RAM, 1TB HDD)
- Music files stored at `/DATA/Media/Music` on host, mounted as `/music` in container
- Songs also appear in Navidrome (separate music server) since they share the same music folder

## Design Direction

The current design is dark-themed, Spotify-inspired, minimal. Improve it to feel more premium and unique – not a Spotify clone but its own identity. The brand name is **Cocofy** with accent color green (#1db954 currently).

---

## YOUR TASKS

### 1. UI/UX Improvements

- Redesign the overall look to feel more premium, polished, and unique (not generic Spotify clone)
- Add smooth transitions and micro-animations (page transitions, hover effects, loading states)
- Improve the mobile experience – make it feel native on iPhone Safari
- Add a "Now Playing" full-screen view when clicking on the player bar (like Spotify's expanded player)
- Add swipe gestures on mobile (swipe up for now playing, swipe to skip)
- Improve search results layout – add ability to switch between grid and list view
- Add skeleton loading states instead of spinner
- Add blur/gradient background that changes based on cover art color (like Apple Music)
- Add smooth scroll-to-top when searching
- 

### 2. New Features to Implement

- **Queue system** – Show upcoming songs, allow reordering, add-to-queue
- **Playlists** – Create, edit, delete playlists. Store in a JSON file or SQLite on server
- **Shuffle & Repeat** – Toggle shuffle mode and repeat (one/all/off)
- **Lyrics** – Fetch and display lyrics (use a free lyrics API or scrape)
- **Search history** – Remember recent searches
- **Favorites** – Heart/like songs, show favorites in sidebar
- **Artist pages** – Click an artist name to see all their songs in library
- **Equalizer** – Basic Web Audio API equalizer (bass, mid, treble)
- **Keyboard shortcuts** – Arrow keys for seek, N/P for next/prev, M for mute
- **Share** – Copy a link to a song (that opens in Cocofy on any Tailscale device)
- **Import playlist from YouTube** – Paste a YouTube playlist URL and download all songs
- **Smart search** – If a song is already in library, show it first before YouTube results
- **Download progress** – Show real download progress percentage, not just spinner
- **Gapless playback** – Preload next song for smooth transitions
- **Album art fallback** – If no embedded art, fetch from a music metadata API
- **Add artist discovery** - when user searches an artist name, also fetch their YouTube Music channel and list all their official songs/albums

### 3. Backend Improvements

- Add SQLite database for proper metadata storage (playlists, favorites, play counts, search history)
- Add WebSocket for real-time download progress
- Add proper error handling and logging
- Add health check endpoint
- Optimize search speed (cache recent searches)
- Add batch download endpoint for playlists
- Add metadata correction – use MusicBrainz API to fix artist/album/title

### 4. Performance

- Lazy load images
- Add service worker for offline support of the UI
- Cache API responses where appropriate
- Optimize audio streaming (byte-range requests for seeking)
- Compress API responses with gzip

### 5. Code Quality

- Add proper Python type hints
- Add error boundaries in frontend JS
- Add loading/error/empty states for all components
- Document all API endpoints
- Keep everything in single files (app.py for backend, index.html for frontend) – do NOT split into multiple files

## IMPORTANT RULES

1. **Single file frontend** – ALL HTML, CSS, and JS must stay in `templates/index.html`. Do not create separate .css or .js files.
2. **No build tools** – No npm, no webpack, no React. Pure HTML/CSS/JS only.
3. **No external CSS frameworks** – No Tailwind, Bootstrap, etc. Custom CSS only.
4. **External JS libraries are OK** via CDN if needed (e.g., for audio visualization).
5. **Mobile-first** – Everything must work perfectly on iPhone Safari via Tailscale.
6. **Keep it fast** – The server is low-end hardware. Don't add heavy processing.
7. **Test locally** – Run `./start.sh` to test. The app runs on `http://127.0.0.1:8888`.
8. **Git workflow** – Commit with clear messages. Push to main triggers auto-deploy to server.
9. **French/Romanian bilingual user** – UI text can stay in Romanian or switch to English, ask user preference.
